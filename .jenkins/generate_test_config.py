import yaml
import os
import argparse
import itertools

def load_template(template_path: str) -> dict:
    """Loads and validates the YAML template."""
    with open(template_path, 'r') as file:
        template = yaml.safe_load(file)
    validate_template(template)
    return template

def validate_template(template: dict):
    """Validates the structure of the YAML template."""
    required_keys = ["env_aliases", "suites"]
    for key in required_keys:
        if key not in template:
            raise ValueError(f"Missing required key: '{key}' in the template.")

    if not isinstance(template["env_aliases"], dict):
        raise ValueError("'env_aliases' must be a dictionary.")

    for suite in template.get("suites", []):
        if not isinstance(suite, dict) or "name" not in suite or "tests" not in suite:
            raise ValueError("Each suite must be a dictionary with 'name' and 'tests' keys.")
        for test in suite["tests"]:
            if not isinstance(test, dict) or "name_template" not in test or "env" not in test or "flavors" not in test or "command" not in test:
                raise ValueError("Each test must have 'name_template', 'env', 'flavors', and 'command' keys.")
            if not isinstance(test["env"], dict):
                raise ValueError("'env' must be a dictionary in each test.")
            if not isinstance(test["flavors"], list):
                raise ValueError("'flavors' must be a list in each test.")
            if not isinstance(test["command"], str):
                raise ValueError("'command' must be a string in each test.")

def expand_combinations(env: dict, flavors: list, env_aliases: dict) -> list:
    """Generates all combinations of environment variables and flavors."""
    expanded_env = {key: values for key, values in env.items()}
    env_keys, env_values = zip(*expanded_env.items())
    env_combinations = [dict(zip(env_keys, values)) for values in itertools.product(*env_values)]
    return [{"env": env_comb, "flavor": flavor} for env_comb in env_combinations for flavor in flavors]

def apply_aliases(env: dict, env_aliases: dict) -> dict:
    """Applies aliases to environment variable values for more descriptive test names."""
    aliased_env = {}
    for key, value in env.items():
        if key in env_aliases and value in env_aliases[key]:
            aliased_env.update(env_aliases[key][value])
        else:
            aliased_env[key] = value
    return aliased_env

def substitute_name_template(template: str, env: dict, flavor: str, test_name: str) -> str:
    """Substitutes placeholders in the name template with actual values."""
    return template.replace("{{ runtime }}", env.get("runtime", "")) \
                   .replace("{{ engine }}", env.get("engine", "")) \
                   .replace("{{ warmup }}", env.get("warmup", "")) \
                   .replace("{{ flavor }}", flavor) \
                   .replace("{{ name }}", test_name)

def flatten_template(template: dict) -> dict:
    """Flattens the hierarchical YAML template into a flat structure."""
    flat_config = {"stages": []}
    env_aliases = template.get("env_aliases", {})

    for suite in template.get("suites", []):
        suite_name = suite["name"]
        steps = []

        for test in suite.get("tests", []):
            combinations = expand_combinations(test["env"], test["flavors"], env_aliases)
            for combo in combinations:
                # Apply aliases to environment variable values
                aliased_env = apply_aliases(combo["env"], env_aliases)
                # Generate the test name using the name template
                test_name = substitute_name_template(test["name_template"], combo["env"], combo["flavor"], test["name"])
                steps.append({
                    "name": test_name,
                    "flavor": combo["flavor"],
                    "command": generate_command(aliased_env, test["command"])
                })

        flat_config["stages"].append({
            "name": suite_name,
            "steps": steps
        })

    return flat_config

def generate_command(env_vars: dict, base_command: str) -> str:
    """Generates the full command by prepending environment variables."""
    env_vars_str = " && ".join(f"export {key}={value}" for key, value in env_vars.items())
    return f"{env_vars_str} && {base_command}" if env_vars else base_command

def save_config(config: dict, output_path: str):
    """Saves the flattened configuration to a YAML file."""
    with open(output_path, 'w') as file:
        # Add disclaimer at the top of the file
        file.write("# THIS FILE WAS GENERATED USING generate_test_config.py\n")
        file.write("# DO NOT EDIT THIS FILE DIRECTLY\n")
        file.write("# Please add tests to test_config_template.yaml and re-generate this file with:\n")
        file.write("# python generate_test_config.py --template-path test_config_template.yaml --output-path test_config.yaml\n")
        yaml.dump(config, file, default_flow_style=False, sort_keys=False)

def generate_env_aliases_with_defaults() -> dict:
    """Generates the env_aliases section with default values."""
    return {
        "runtime": {
            "eager": {"PT_HPU_LAZY_MODE": "0"},
            "lazy": {"PT_HPU_LAZY_MODE": "1"},
            "default": "lazy",
        },
        "engine": {
            "v0": {"VLLM_USE_V1": "0"},
            "v1": {"VLLM_USE_V1": "1"},
            "default": "v0",
        },
        "warmup": {
            "skip_warmup": {"VLLM_SKIP_WARMUP": "true"},
            "do_warmup": {"VLLM_SKIP_WARMUP": "false"},
            "default": "skip_warmup",
        },
    }

def generate_test_config(flat_config_path: str, output_path: str):
    """Generates the test configuration YAML with default env_aliases."""
    env_aliases = generate_env_aliases_with_defaults()
    with open(flat_config_path, 'r') as file:
        flat_config = yaml.safe_load(file)

    clustered_config = clusterize_tests(flat_config, env_aliases)

    with open(output_path, 'w') as file:
        yaml.dump(clustered_config, file, default_flow_style=False, sort_keys=False)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Flatten a hierarchical YAML template into a flat configuration.")
    parser.add_argument("--template-path", type=str, required=True, help="Path to the YAML template file.")
    parser.add_argument("--output-path", type=str, required=True, help="Path to save the flattened configuration.")
    args = parser.parse_args()

    template = load_template(args.template_path)
    flat_config = flatten_template(template)
    save_config(flat_config, args.output_path)
    print(f"Flattened configuration saved to {args.output_path}")
